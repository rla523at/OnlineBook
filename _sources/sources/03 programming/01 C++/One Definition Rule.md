# One Definition Rule
`유일 정의 규칙(one definition rule, ODR)`이란 "각 `해석유닛(translation unit, TU)`에 존재하는 모든 변수, 함수, 클래스, enum, 템플릿 등등의 `정의(definition)`은 유일해야 하고 inline 이 아닌 정의는 전체 프로그램에서 유일해야 한다" 는 규칙이다.

유일 정의 규칙을 알아보기 전에 먼저 정의가 무엇인지 보자.

## 정의와 선언

우리는 종종 정의와 선언을 혼동해서 사용한다. 하지만 C++에서 이 둘은 엄연히 다른 개념이다. 먼저 `선언(declaration)`이란 TU에 새로운 이름을 도입하거나, 기존에 선언된 이름을 재선언 하는 것이다.

정의는 선언을 포함하는 개념으로, 선언된 개체를 완전히 정의함을 뜻한다. 따라서 모든 정의는 선언이다.

선언과 정의의 예시를 보면 다음과 같다.

```cpp
int f();                //함수를 선언
int f() { return 0; }   //함수를 정의, 정의하기 위해서는 반드시 함수의 몸체를 제공해야 함
class A;                //클래스를 선언
class A {};             //클래스를 정의
int a;                  //변수를 정의, 일반적인 변수의 경우 선언과 정의는 동일
extern const int a;     //변수를 선언, extern 지정자가 들어간 경우 명시적으로 초기화되지 않을 경우 선언
extern const int b = 1; //변수를 정의
struct S 
{
  int n;                // S::n 정의
  static int i;         // S::i 를 선언하지만 정의는 아님
  inline static int x;  // S::x 를 정의
};                      // S 를 정의
int S::i;               // S::i 를 정의
```

## 유일 정의 규칙

유일 정의 규칙은 각 TU에 존재하는 모든 변수, 함수, 클래스, enum, 템플릿 등등의 정의는 유일해야 하며 inline이 아닌 정의는 전체 프로그램을를 통틀어 유일해야 한다는 규칙이다.

먼저 첫 번째 문장은 "각 TU에 존재하는 모든 변수, 함수, 클래스 등등의 정의는 유일해야 한다" 이다. 이 말은 TU 안에 같은 선언은 여러개 있어도 괜찮다는 의미이다.

```cpp
int f();  // f 의 선언
int f();  // f 의 선언
int f();  // f 의 선언

int g() { return 0; } // g의 정의
int g();  // g의 선언
int g();  // g의 선언

int main() {}
```

위 코드는 아무런 문제 없이 컴파일 된다. 왜냐하면 f는 선언만 여러번 됐지 정의가 여러번 된것이 아니기 때문이며 g의 정의는 유일하기 때문에 문법적으로 아주 올바른 C++코드 이다.

## inline 키워드의 의미

두번째 문장은 'inline이 아닌 정의는 전체 프로그램에서 유일해야 한다.' 이다. 이 말은 inline 으로 정의되지 않는 모든 함수들과 변수들의 경우 프로그램을 구성하는 모든 TU에서 정의가 단 하나만 있어야 한다는 의미이며 동시에 inline인 변수나 함수의 경우 이를 사용하고자 하는 TU 안에 반드시 정의되어 있어야 한다는 의미이다.

그렇다면 아래의 코드를 보자.

```cpp
//Common.h
int g_common_value;
void common_function(void) {};
inline int g_inline_value;
static int g_static_value;

//A.cpp TU1
#include "Common.h"

//B.cpp TU2
#include "Common.h"
```

이 경우에는 컴파일은 잘 되지만 링크에서 문제가 발생한다. 왜냐하면 inline이 아닌 변수 g\_common\_value와 common\_function의 정의가 전체 TU에서 유일하지 않기 때문이다. 그에 비해 정적 전역 변수인 g\_static\_value는 아무런 문제도 발생시키지 않는데 이는 static 지시자로 인해 각 TU에서만 유효한 변수로 취급되어 중복되지 않기 때문이다.

앞서 ODR에서 inline인 변수나 함수의 경우 이를 사용하고자 하는 TU 안에 반드시 정의되어 있어야 한다고 하였다. 원래 inline 키워드가 처음 도입되었을 때 의미는 컴파일러에게 '이 함수를 호출하는 문장을 그냥 이 함수의 내용으로 치환시켜도 된다' 라는 의미였다. (단 한 번도 이 함수를 반드시 인라인화 시켜야 한다 라는 의미 였던 적은 없다)

하지만 현재의 C++ 컴파일러는 굉장히 똑똑해졌기 때문에 우리가 굳이 inline 이라고 명시 하지 않아도 만일 inline 하는게 성능 면에서 낫다고 생각하는 경우 그냥 함수를 inline 해버린다. 반대로 inline인 함수여도 컴파일러가 생각했을 때 inline 하지 않는 것이 낫다고 판단한다면 inline 하지 않는다.

따라서 inline 키워드는 "이 함수는 여러개의 TU에 정의되어 있어도 괜찮다" 는 의미로 받아들이면 된다. 쉽게 말해 inline인 함수의 경우 전체 프로그램에서 여러 군데에 정의가 되어 있어도 상관이 없지만 해당 함수를 사용하는 TU 안에서는 inline 함수의 정의가 반드시 들어 있어야 한다. 이렇게 inline 키워드의 의미가 변질되었기 때문에 C++ 17에서는 일반적인 변수 자체도 "여러 정의를 허용한다" 라는 의미에서 inline으로 사용할 수 있다.

이와 반대로 inline이 아닌 함수의 경우 사용하기 위해서 반드시 TU에 해당 함수의 정의가 있을 필요는 없지만, 대신 전체 TU에 정의가 반드시 단 한개만 있어야 한다. 예를 들어서 inline 함수는 헤더파일에 정의해도 상관 없다. 한 가지 재미있는 점은 클래스 내부에 정의되어 있는 함수들은 자동으로 inline이라는 점이다.

```cpp
class A 
{
public:
    int Func1() { return 0; }   // 클래스 안에 정의된 멤버 함수는 inline으로 분류 됨
    int Func2();                // 클래스 안에 선언된 멤버 함수는 inline으로 분류되지 않음
};

int A::Func() { return 0; }     // inline이 아닌 함수로 취급되어 TU 전체에 정의가 딱 하나 있어야 함.
```